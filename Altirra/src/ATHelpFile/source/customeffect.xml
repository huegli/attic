<?xml version='1.0' standalone='yes'?>
<?xml-stylesheet type="text/xsl" href="index.xsl" ?>
<topic title="Custom effects">
  <toc/>
  <p>
    The custom effect file formats are modeled after the <tt>.cgp</tt> format used by
    the RetroArch emulator. Some adjustments have been made to account for differences
    between the emulators and between the Cg and HLSL shader languages, so custom effects
    will sometimes require adjustment to run on Altirra.
  </p>
  <h2>Using a custom effect</h2>
  <p>
    A custom effect is configured in Configure System under Display 2, Custom Effect path.
    This points to a <tt>.cgp</tt> file that describes the shader stages of the effect
    to render during display composition.
  </p>
  <p>
    Either Direct3D 9 or Direct3D 11 must be enabled for custom effects to work (these
    are enabled by default).
  </p>
  <h2>Basic structure</h2>
  <p>
    A custom effect pipeline is composed of one or more passes, each of which runs a pair
    of vertex and pixel shaders to produce a new image. Each pass can refer to the output
    of <i>any</i> previous stage, not just the source. Passes can also read from <i>past</i>
    frames on inputs, allowing for multi-frame filters.
  </p>
  <p>
    The effect pipeline is described in a primary <tt>.cgp</tt> file which enumerates the
    passes and their settings, and also references auxiliary shader source and texture image
    files. The <tt>cgp</tt> format is a simple text file containing a property list of the
    form <tt>name = value</tt>. Double-quotes around the value are optional unless the
    value contains spaces. The order of properties in the file does not matter.
  </p>
  <p>
    Comments start with a hash mark (<tt>#</tt>). They can begin mid-line, in which case
    everything to the end of the line is treated as a comment.
  </p>
  <p>
    For properties that have boolean values, the value may either be <tt>0</tt> or <tt>false</tt>
    for a false value, and <tt>1</tt> or <tt>true</tt> for a true value.
  </p>
  <h2>Global declarations</h2>
  <p>
    Global declarations apply to all passes.
  </p>
  <dl class="scripting-ref">
    <dt>shaders</dt>
    <dd>
      Specifies the number of shader passes. For instance, <tt>shaders = 2</tt> indicates
      two passes. An error is thrown if there are not at least the specified number of passes,
      by the <tt>shader0</tt>, <tt>shader1</tt>, etc. parameters. Any additional passes are
      ignored, so this can be used to debug a specific pass.
    </dd>
    <dd>
      If this parameter is omitted, all contiguous passes starting with <tt>shader0</tt> are
      used.
    </dd>
      
    <dt>shader_profile_d3d9</dt>
    <dd>
      Sets the shader profile used for compiling shaders for Direct3D 9. Valid values are
      <tt>2_0</tt>, <tt>2_a</tt>, <tt>2_b</tt>, and <tt>3_0</tt>. These correspond to
      shader model 2.0, 2.a, 2.b, and 3.0, with 2.0 being the most compatible and 3.0
      being the most powerful/flexible.
    </dd>
    <dd>
      Shader model 2.a/2.b and 3.0 hardware can run 2.0 shaders, and 3.0 hardware can run all
      profiles. If the hardware does not support the specified profile, the whole custom effect
      will fail to load.
    </dd>
    <dd>
      The default is the highest shader model supported by the graphics device in Direct3D 9.
    </dd>

    <dt>shader_profile_d3d11</dt>
    <dd>
      Sets the shader profile used for compiling shaders for Direct3D 11. Valid values are
      <tt>4_0_level_9_1</tt>, <tt>4_0_level_9_3</tt>, <tt>4_0</tt>, and <tt>5_0</tt>.
      These approximately correspond to shader models 2, 3, 4, and 5.
    </dd>
    <dd>
      If not specified, the default is the highest supported profile for the device in Direct3D 11.
    </dd>

    <dt>shader_precompile</dt>
    <dd>
      For Direct3D 9, if <tt>true</tt>, always compile the shaders from source and write the precompiled shaders
      to disk with the suffix <tt>-d3d9.vsh</tt> or <tt>-d3d9-psh</tt>. This is the same binary
      format produced by the <tt>fxc</tt> tool in the DirectX or Windows SDK.
    </dd>
    <dd>
      The default is <tt>false</tt>, which means to use precompiled shaders if they exist or
      otherwise attempt to compile from source, but never to write precompiled shaders.
    </dd>
    <dd>
      This setting is currently ignored for Direct3D 11, which always compiles shaders.
    </dd>

    <dt>shader_show_stats</dt>
    <dd>
      Displays stats on screen for the output surface format and GPU timings for each pass if
      available. This is useful to tell which passes are the most expensive. The default is
      <tt>false</tt>.
    </dd>
    <dd>
      This can also be enabled by setting the advanced configuration variable <tt>display.customeffect.show_stats</tt>
      in Altirra in Tools &gt; Advanced Configuration.
    </dd>

    <dt>textures</dt>
    <dd>
      Semicolon-delimited list of names of textures to load: <tt>abc;def</tt> specifies that
      <tt>abc</tt> and <tt>def</tt> are texture names. Each of these is then expected to be
      declared with the name of the file to load as the texture image, e.g. <tt>abc = image.png</tt>.
    </dd>
    <dd>
      Texture source images may either be in PNG or TARGA format. For PNG files, only opaque images
      are supported. For TARGA, the alpha channel is optional but supported.
    </dd>

    <dt><i>texture</i>_linear</dt>
    <dd>
      If <tt>true</tt>, use bilinear filtering for <i>texture</i>. For instance, <tt>background_linear</tt>
      sets the filtering mode for texture <tt>background</tt>. If
      <tt>false</tt>, use nearest (point) sampling. If omitted, the default is <tt>true</tt> (bilinear).      
    </dd>
  </dl>

  <h2>Pass declarations</h2>
  <p>
    Pass declarations only apply to a specific pass. All pass declarations are suffixed with the
    pass number, starting at <tt>0</tt> for the first pass.
  </p>
  <dl class="scripting-ref">
    <dt>shader<i>N</i></dt>
    <dd>
      Declares pass <i>N</i> and sets the name of the shader source file for that pass. Passes are
      numbered from 0 upward and must be numbered sequentially.
    </dd>
    <dd>
      The shader file is in HLSL format for Direct3D 9. Conventionally, it has the <tt>.fx</tt> file
      extension, though this is not required.
    </dd>

    <dt>shader_profile_d3d9_<i>N</i></dt>
    <dd>
      Same as <tt>shader_profile_d3d9</tt>, but overriding it only for pass <i>N</i>. If omitted, the global
      setting is used.
    </dd>

    <dt>shader_profile_d3d11_<i>N</i></dt>
    <dd>
      Same as <tt>shader_profile_d3d11</tt>, but overriding it only for pass <i>N</i>. If omitted, the global
      setting is used.
    </dd>
    
    <dt>filter_linear<i>N</i></dt>
    <dd>
      If <tt>true</tt>, use bilinear filtering for the default input of pass <i>N</i>. If
      <tt>false</tt>, use nearest (point) sampling. If omitted, the default is <tt>true</tt> (bilinear).
    </dd>

    <dt>scale_type<i>N</i>, scale_type_x<i>N</i>, scale_type<i>N</i></dt>
    <dd>
      Sets the output size type for pass <i>N</i>. <tt>source</tt> uses the size of the default source input for
      the pass (not necessarily the original source to the whole effect). <tt>viewport</tt> uses the
      size of the final output that the effect renders to. <tt>absolute</tt> just uses a reference
      size of 1x1 so that the scale factor is the output size in pixels.
    </dd>
    <dd>
      If not specified, the default is <tt>source</tt>, with one exception for the final pass. If the
      final pass has no scale type specified, it renders at <tt>source</tt> size but the output is
      routed through the default scaler to <tt>viewport</tt> size. If the final pass does specify a
      scale type, the default scaler is bypassed.
    </dd>

    <dt>scale<i>N</i>, scale_x<i>N</i>, scale_y<i>N</i></dt>
    <dd>
      Sets the output scaling factors for pass <i>N</i> for both axes, only the x-axis, or only the y-axis. Required if
      a scale type is specified. For instance,
      <tt>scale_x2 = 2.5</tt> makes the output width of pass 2 2.5 times the size of the scaling reference
      size (source/viewport/absolute, depending on scaling type).
    </dd>

    <dt>frame_count_mod<i>N</i></dt>
    <dd>
      Specifies a modulus value for pass <i>N</i>'s frame counter, such that the frame count
      repeats from 0 before reaching the specified value. For instance, a <tt>frame_count_mod</tt>
      of 3 causes the frame count to cycle 0, 1, and 2.
    </dd>
    <dd>
      If <tt>frame_count_mod</tt> is omitted, the frame counter counts up indefinitely from 0.
    </dd>

    <dt>float_framebuffer<i>N</i></dt>
    <dd>
      If <tt>true</tt>, specifies that the output surface for pass <i>N</i> should use 32-bit
      floating point format for each channel instead of 8-bit fixed point. This gives much
      better precision and range, but is significantly slower and should be used sparingly.
    </dd>
    <dd>
      If the device does not support full floating point textures, half-float textures are used
      if available.
    </dd>

    <dt>halffloat_framebuffer<i>N</i></dt>
    <dd>
      If <tt>true</tt> and <tt>float_framebuffer</tt> is also set, specifies that the output
      surface for pass <i>N</i> should use 16-bit per channel half-float format instead of
      full 32-bit float per channel. This is generally faster than full float while still
      better in precision and range than fixed point.
    </dd>
    <dd>
      If the device does not support half-float point textures, full-float textures are used
      if available.
    </dd>

    <dt>srgb_framebuffer<i>N</i></dt>
    <dd>
      Enables hardware sRGB conversion for the output of pass N. If set, reads from the output
      texture are converted from sRGB to linear color, and writes are converted from linear
      color to sRGB.
    </dd>
  </dl>

  <h2>Pass execution</h2>
  
  <h3>Input geometry</h3>
  <p>
    The input geometry for each pass is a single quad aligned to the output surface, with two
    UV attribute sets. The first UV set (<tt>TEXCOORD0</tt>) contains texture
    coordinates for the pass input texture, while the second UV set (<tt>TEXCOORD1</tt>)
    contains normalized 0-1 coordinates for the quad and is useful for calculating other
    texture coordinates or quantities. The two will be different if the source image is
    in a sub-rect of the texture.
  </p>
  <p>
    On Direct3D 9, the quad vertices are automatically adjusted to account for the half pixel
    offset, so the UVs should not be adjusted. For a 512x512 image in a 512x512 texture,
    the UVs should span 0-1 exactly.
  </p>

  <h3>Shaders</h3>
  <p>
    The <tt>.fx</tt> file referenced by the <tt>shader<i>N</i></tt> property is expected to
    contain two shader programs, a vertex shader called <tt>main_vertex</tt> and a
    fragment (pixel) shader called <tt>main_fragment</tt>. These are used together in the
    graphics pipeline to draw the pass output.
  </p>
  <p>
    The vertex shader <tt>main_vertex</tt> can accept input attributes with <tt>POSITION</tt>,
    <tt>TEXCOORD/TEXCOORD0</tt>, and <tt>TEXCOORD1</tt> semantics. It can output any attributes
    needed by the fragment shader and allowed by the shader profile.
  </p>
  <p>
    By default, the vertex and fragment shader are compiled as <tt>vs_2_0</tt> and <tt>ps_2_0</tt>
    for best compatibility. This may be limiting for more complex shaders. The <tt>shader_profile_d3d9</tt>
    property can be used to raise the profile.
  </p>

  <h3>Rasterization and output merging</h3>
  <p>
    Backface culling is disabled, so triangles may be output in either winding order. Viewport
    and scissor are also enabled so that oversize triangles may be used to cover the viewport.
    Passes are expected to render over the entire output surface each frame.
  </p>
  <p>
    Blending is disabled on the output surface, so the output of the fragment shader is written
    without modification. Destination alpha is enabled.
  </p>
  <p>
    In the final pass, the output surface may be 16-bit (555) if the final pass is writing directly
    to the output framebuffer and 16-bit output has been forced in host options. The default
    is 32-bit output, however.
  </p>

  <h3>Uniform inputs</h3>
  <p>
    The original <tt>.cgp</tt> specification assumed a Cg-based implementation, so some adjustments
    have been made for HLSL support. In particular, HLSL on Direct3D 9 does not support texture
    objects within structures, so they have been broken apart as separate <tt>_texture</tt>
    suffixed parameters.
  </p>
  <p>
    Any unrecognized textures bound to texture/sampler 0 are mapped to the <tt>IN</tt>
    parameter. This allows simply <tt>extern</tt>-ing the input texture as register <tt>s0</tt>:
  </p>
  <pre>extern sampler IN_texture : register(s0)</pre>
  <p>
    All other textures can be referred to by name, with slots auto-allocated by the shader
    compiler. Each input <tt>FOO</tt> has a sampler parameter named <tt>FOO_texture</tt>
    and a struct parameter named <tt>FOO</tt>. Both of these are declared as <tt>uniform</tt>
    parameters to the shader and not as a global parameters.
  </p>
  <dl class="scripting-ref">
    <dt>IN</dt>
    <dd>
      The pass input, either the output of the previous pass or the source texture for
      pass 0.
    </dd>

    <dt>ORIG</dt>
    <dd>
      The input to pass 0, the original source.
    </dd>

    <dt>PASS<i>N</i></dt>
    <dd>
      The pass input for pass <i>N</i>. For instance, <tt>PASS2</tt> gives the
      input to pass 2, or the third pass. <i>N</i> must be be less than the current pass
      number.
    </dd>
    <dd>
      <tt>PASS0</tt> is not allowed for the original source; use <tt>ORIG</tt>
      for that. Similarly, <tt>PASS<i>N</i></tt> is not allowed for the current pass
      input, which must use IN (register <tt>s0</tt>) instead.
    </dd>

    <dt>PREV, PREV<i>M</i></dt>
    <dd>
      The original input from the previous frame, or from <i>M+1</i> frames back. That is,
      <tt>PREV</tt> is the previous frame version of <tt>ORIG</tt>, while <tt>PREV1</tt>
      is one frame behind <tt>PREV</tt>. Up to <tt>PREV6</tt> is supported.
    </dd>
    <dd>
      Note that the number on <tt>PREV<i>M</i></tt> is a frame offset number, <i>not</i>
      a pass number. Previous frames can only be referenced on the immediate pass input.
    </dd>
  
    <dt>PASSPREV, PASSPREV<i>M</i></dt>
    <dd>
      Alternate way of accessing previous pass inputs. <tt>PASSPREV</tt> is the input to the
      previous pass, <tt>PASSPREV1</tt> the input to two passes back, etc. This indexes passes
      backwards from the current pass, versus <tt>PASS</tt> which numbers passes forwards from
      the start.
    </dd>
  </dl>
  <p>
    The struct parameter has the following fields:
  </p>
  <dl class="scripting-ref">
    <dt>float2 video_size;</dt>
    <dd>
      The size of the valid image within the texture. For a 320x200 image within a 512x256
      texture, <tt>video_size</tt> is (320, 200).
    </dd>

    <dt>float2 texture_size;</dt>
    <dd>
      The size of texture in texels. For a 320x200 image within a 512x256
      texture, <tt>video_size</tt> is (512, 256).
    </dd>

    <dt>float2 output_size;</dt>
    <dd>
      The valid image size in texels for the pass associated with the texture. <tt>IN.output_size</tt>
      is the output size for the current pass.
    </dd>
    
    <dt>float frame_count;</dt>
    <dd>
      The frame number represented by this input, starting with 0. For a <tt>PREV</tt>
      frame, this frame number is appopriately lower from <tt>IN</tt>.
    </dd>

    <dt>float frame_direction;</dt>
    <dd>
      Always 1, since custom effects are always run forward in Altirra.
    </dd>
  </dl>

  <p>
    The matrix shader parameter <tt>modelViewProj</tt> provides the model-view-projection transform
    to convert from the input vertex positions to output clip coordinates. The input position
    should be transformed by this matrix in the vertex shader.
  </p>
  <p>
    <b>Note:</b> For compatibility reasons, <tt>modelViewProj</tt> is expected to be multiplied
    on the left of the input position vector, i.e. <tt>mul(modelViewProj, position)</tt>. In Altirra,
    either order will work since <tt>modelViewProj</tt> is always identity.
  </p>

  <h3>Custom texture inputs</h3>
  <p>
    Any custom textures declared with <tt>textures</tt> appear as global uniform parameters with
    the same name.
  </p>
  <p>
    Custom textures are always allocated with the exact size of the image. If the device only supports
    power-of-two textures and the image dimensions are not powers of two, the texture load fails.
  </p>
  
  <h3>Texture settings</h3>
  <p>
    All textures, including the texture texture and pass output textures, use top-down orientation
    for texture coordinates with (0,0) as the top left.
  </p>
  <p>
    Non-power-of-two textures may be stored in power-of-two sized textures due to hardware limitations
    or for speed. When available, <tt>BORDER</tt> addressing is used to ensure that texture sampling
    outside of the valid image area of the texture returns transparent black.
  </p>

  <h2>Direct3D 11 specific issues</h2>
  <p>
    In Direct3D 11 mode, shaders are compiled with the FXC <tt>/Gec</tt> compatibility option. This
    enables backwards compatibility with Direct3D 9 shaders, including accepting D3D9 semantics
    (<tt>POSITION</tt> instead of <tt>SV_Position</tt>, <tt>COLOR0</tt> instead of <tt>SV_Target</tt>),
    and D3D9-style <tt>tex2D()</tt> intrinsics. This allows D3D9-compatible shaders to be used in
    D3D11 mode as well with minor modifications.
  </p>
  <p>
    The main requirement for D3D11 compatibility is that the pixel shader input signature must
    be compatible with the vertex shader input signature. This means that all pixel shader varying
    attribute inputs must be a subset of the vertex shader inputs, <i>in order</i>. For instance,
    if the pixel shader accepts <tt>float2 : TEXCOORD0</tt> and <tt>float3 : TEXCOORD1</tt>, the
    vertex shader must output at least <tt>TEXCOORD0</tt> and <tt>TEXCOORD1</tt> as the first
    two varying attributes, in that order, with at least <tt>float2</tt> and <tt>float3</tt>
    components. The custom effect loader validates this and will throw an error if the signatures
    are not compatible. The most common error is due to outputting <tt>POSITION</tt> from the
    vertex shader before other varying attributes, which can be fixed by moving it to the end.
  </p>
  <p>
    The custom effect loader also maps the D3D9 <tt>half</tt> types to <tt>min16float</tt> if supported
    by the device, to take advantage of double-speed half float arithmetic.
  </p>

  <h2>Interaction with host UI</h2>
  <p>
    Custom effects are expected to render source contents in approximately the same location as
    the standard rendering path. They may still render with arbitrary transform, but this may
    cause a visual disconnect between the host UI and the rendered image. The UI depends upon
    the position of elements in the rendered image for the following features:
  </p>
  <ul>
    <li>Text selection</li>
    <li>Light pen/gun position tracking</li>
    <li>The inspection tool, triggered by Ctrl+Alt+click</li>
    <li>Debugger tools showing the current beam position</li>
  </ul>
  <p>
    These features will all still work regardless of custom effect rendering, but the image produced
    by the custom effect may not line up with the position shown or used by the UI. For instance,
    if the custom effect scales down the image vertically, the text selection highlight may be
    drawn larger than the location of the text in the final image.
  </p>
  <p>
    The scaling and aspect ratio options, however, do not need to be handled by custom effects. These
    settings are already taken into account in the viewport size rendered by the custom effect, and
    any letterboxing performed to maintain scaling/aspect is outside of the viewport. The image processing
    performed in the custom effect does not affect the border color.
  </p>
  
  <h2>Interaction with post-processing</h2>
  <p>
    If the final pass contains scaling settings, it is considered to replace the built-in post-processing
    pipeline. This disables the default scaling and screen effect passes.
  </p>

  <h2>Precompiling shaders for distribution</h2>
  <p>
    Compiling shaders from source requires <tt>D3DCompiler_47.dll</tt>. This DLL is always available
    as a pre-installed system DLL on Windows 8.1 and Windows 10, but for earlier versions of the OS
    requires a redistributable that is not shipped with Altirra.
    For this reason, custom shaders can be precompiled to binary form with <tt>shader_precompile = true</tt>
    to work on all systems. The <tt>.cgp</tt> should be loaded once with this setting to create or
    refresh the <tt>.vsh</tt> and <tt>.psh</tt> files, then the setting turned back off for
    distribution.
  </p>
  <p>
    There is no difference in performance between source-compiled and precompiled shaders, besides
    a very small amount of time to compile from source on load in the former case.
  </p>
  <p>
    Precompiled shaders are only supported for Direct3D 9.
  </p>

  <h2>Performance optimization</h2>
  <p>
    The speed of the vertex shader is a non-issue due to the very low vertex count involved, but
    the performance of the fragment shader can become a serious bottleneck with complex or multi-pass
    effects are involved. The <tt>shader_show_stats</tt> property can be used to display GPU pass
    timings to identify the most expensive passes that are in need of optimization. All passes of the
    custom effect must run in under 16ms to maintain 60fps and needs to run considerably faster than
    that to avoid adversely affecting vsync lock. Running within 8ms or lower is highly recommended.
  </p>
  <p>
    Pass outputs can be cached if they do not reference the original input or any other passes
    referencing the original input.
  </p>
  <p>
    Structure passes so that as much processing as possible is done at the smallest size. Color
    processing is often commutative with scaling, so do the color processing at source resolution
    and then upscale.
  </p>
  <p>
    Floating-point format surfaces are more expensive due to the memory bandwidth involved.
    When possible, use the default fixed point surface format (32-bit RGBA), or use half-float if
    full float precision is not needed.
  </p>
  <p>
    Hoisting non-trivial math from the fragment shader to the vertex shader can substantially
    speed up the fragment shader, as long as the linear attribute interpolation is acceptable for
    the hoisted quantity.
  </p>
  <p>
    Some GPUs benefit from use of the <tt>half</tt> type in fragment shaders. Intel Skylake architecture
    GPUs, for instance, can run double-speed math with half precision.
  </p>

  <h2>Sample effect</h2>
  <h3>Invert</h3>
  <p>
    This effect inverts all colors in the image, producing a negative where black becomes white and
    vice versa.
  </p>
  <h4>invert.cgp</h4>
  <blockquote><pre>shader0 = "invert.fx"
filter_linear0 = "true"
scale_type_x0 = "viewport"
scale_x0 = "1"
scale_type_y0 = "viewport"
scale_y0 = "1.000000"</pre></blockquote>
  <h4>invert.fx</h4>
  <blockquote><pre>extern sampler src : register(s0);

void main_vertex(
    float4 pos : POSITION,
    float2 uv : TEXCOORD0,
    uniform float4x4 modelViewProj,
    out float2 oT0 : TEXCOORD0,
    out float4 oPos : POSITION)
{
    oPos = mul(modelViewProj, pos);
    oT0 = uv;
}

half4 main_fragment(float2 uv : TEXCOORD0) : COLOR0 {
    half4 c = tex2D(src, uv);
    c.rgb = 1.0h - c.rgb;

    return c;
}</pre></blockquote>
</topic>
